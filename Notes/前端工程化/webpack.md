## 基本打包机制
本质上webpack是一个现代的JS应用程序的静态模块打包器(module bundler)。当webpack处理应用程序时，他会递归的构建一个依赖关系图,其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。

打包过程可以分为4步

1. 利用babel完成代码转换，并生成单个文件的依赖
2. 从入口开始递归分析，并生成依赖图谱
3. 将各个引用模块打包为一个立即执行函数
4. 将最终的bundle我呢见写入bundle.js中

### 扩展：
1. 初始化参数 从配置文件和shell语句中读取和合并参数
2. 开始编译 用上一步获得的参数初始化对象，加载所有配置的插件，通过执行的对象的run方法执行编译
3. 确认入口 根据配置中的entry找出所有入口文件
4. 编译模块 从入口文件出发，调用所有Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
5. 完成模块编译 在经过第4步使用 Loader 翻译完所有模块后， 得到了每个模块被编译后的最终内容及它们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk,再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。

### loader
Loader 就像一个翻译员，能将源文件经过转化后输出新的结果，并且一个文件还可以链式地经过多个翻译员翻译。
- 一个Loader 的职责是单一的，只需要完成一种转换
- 一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数

### Plugin
专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件
- 是一个独立的模块
- 模块对外暴露一个 js 函数
- 函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply 方法 apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback
- 完成自定义子编译流程并处理 complition 对象的内部数据
- 如果异步编译插件的话，数据处理完成后执行 callback 回调。