### var let const

let/const 也存在变量声明提升，只是没有初始化分配内存。 一个变量有三个操作，声明(提到作用域顶部)，初始化(赋默认值)，赋值(继续赋值)。

var 是一开始变量声明提升，然后初始化成 undefined，代码执行到那行的时候赋值。
let 是一开始变量声明提升，然后没有初始化分配内存，代码执行到那行初始化，之后对变量继续操作是赋值。因为没有初始化分配内存，所以会报错，这是暂时性死区。
const 是只有声明和初始化，没有赋值操作，所以不可变。

const 只是保证了指向的内存地址不变，而不是内部数据结构不变。确保不会被其他类型的值所替代。

### 作用域链，继承以及原型链


作用域
作用域是定义变量可访问范围的一套规则，决定了程序中哪里可以访问或使用这些变量。 分为词法作用域和动态作用域。
按查找规则分为：

词法作用域（Lexical Scope） ：在代码编写时确定，由代码嵌套结构决定。变量查找是从当前作用域向上查找，直到全局作用域。
动态作用域（Dynamic Scope） ：变量查找是在函数调用时根据调用栈来决定，而不是代码结构。比如this。

按作用域的范围分为：


全局作用域
在代码的最外层定义的变量拥有全局作用域，它们可以在代码的任何地方被访问。在浏览器环境下，全局作用域通常绑定到window对象上。在node环境下，全局作用域通常绑定到global对象上
注意： 使用let和const声明的变量不会挂载到window对象上。这一改变是ES6引入块级作用域的一个重要特性，旨在解决变量声明提升和变量污染问题。解决方案是TDZ。


函数作用域 在函数内部定义的变量拥有函数作用域，它们只在该函数内部及嵌套的函数内部可见。


块级作用域（ES6引入） 使用let和const声明的变量具有块级作用域，这意味着它们只在定义它们的代码块（如if语句或for循环）内部可见。


暂时性死区（TDZ, Temporal Dead Zone）  在使用let和const声明变量之前，该变量在其声明之前的区域被称为暂时性死区，任何访问该变量的尝试都将导致错误。
作用域链


当JavaScript引擎需要查找一个变量的值时，它会遵循一定的规则去查找，这个查找路径就是作用域链。作用域链是由当前执行环境的作用域与其所有外部作用域组成的链式结构。


每个函数在创建时，都会生成一个新的执行上下文，这个执行上下文中会包含一个指向其外部作用域的引用，这样就形成了一个链式结构。
