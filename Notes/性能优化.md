### 网络优化

DNS预解析（link 标签得rel属性设置dns-prefetch）
使用缓存（etag / expires ...）
使用CDN
压缩响应
减少不必要的数据返回
使用gzip

### 页面渲染优化

减少css复杂度
避免js阻塞
iconfont代替图标图片
首屏加载优化，骨架屏，动画
减少重绘和回流
不同资源放在不同域下 (http1.1)

### JS优化
使用时间委托
防抖和节流
尽量不要使用JS动画（css动画和canvas动画都比js动画性能好）
多线程（复杂计算启用webWorker进行计算，防止页面假死）
计算接管缓存（减少运算次数，比如vue中的computed）
减少http请求

### 图片优化
雪碧图
图片懒加载
css3代替图片
图片压缩
渐进式jpeg
使用webp格式得图片

### webpack打包优化
缩小loader匹配范围（优化配置，test，include，exclude缩小处理范围）
tree shaking去除无用代码
提取公用包
拆分模块
优化图片
file name with hash (etag)

### React优化
● map循环展示添加key
● 路由懒加载
● 第三方插件按需引入
● 使用scu，memo或者pureComponent避免不必要的渲染
● 合理使用useMemo、memo、useCallback他们三个的应用场景都是缓存结果，当依赖值没有改变时避免不必要的计算或者渲染。
● useCallback 是针对函数进行“记忆”的，当它依赖项没有发生改变时，那么该函数的引用并不会随着组件的刷新而被重新赋值。当我们觉得一个函数不需要随着组件的更新而更新引用地址的时候，我们就可以使用 useCallback 去修饰它。
● React.memo 是对组件进行 “记忆”，当它接收的 props 没有发生改变的时候，那么它将返回上次渲染的结果，不会重新执行函数返回新的渲染结果。
● React.useMemo是针对 值计算 的一种“记忆“，当依赖项没有发生改变时，那么无需再去计算，直接使用之前的值，对于组件而言，这带来的一个好处就是，可以减少一些计算，避免一些多余的渲染。当我们遇到一些数据需要在组件内部进行计算的时候，可以考虑一下 React.useMemo

### Vue优化
v-for添加key
路由懒加载
第三方插件按需引入
合理使用computed和watch
v-of避免v-if
destory时销毁事件：比如addEventListener添加的事件、setTimeout、setInterval、bus.$on绑定的监听事件等
