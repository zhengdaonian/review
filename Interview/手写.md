### 手写promise

### 实现一个节流函数? 如果想要最后一次必须执行的话怎么实现?

### 手写promise

### 手写bind

### 手写eventEmitter
跟 promise class 一样，先搭建一个框架：
class EventEmitter {
constructor() {
this.events = {}
}
emit (eventName, args) {}
on (eventName, callback) {}
off (eventName, callback?) {}
}
复制代码之前有写过事件系统，但是没有考虑 once 之类的 method，也是面试官说了需求再一点点补充的。

### 手写 Proxy / Object.defineProperty
实际只是要求两者的比较以及如何运用


### 手写深拷贝

### 、实现instanceOf的3种方法
```
function myInstanceof(obj, func) {    
	if(!['function', 'object'].includes(typeof obj) || obj === null) {     
		// 基本数据类型直接返回false，因为不满足instanceof的左侧参数是对象或者说引用类型        
			return false    
	}    
	let proto = obj.__proto__, prototype = func.prototype    
	while(proto !== prototype) {     
		// obj.__proto__不等于func.prototype时，继续通过__proto__向上层查找     
		// 当找到原型链尽头Object.prototype.__proto__=null 时还未找到，就返回false        
		proto = proto.__proto__        
		if(proto === null){            
			return false       
		}    
	}    
// obj.__proto__ 等于 prototype = func.prototype 时，不会进入上面循环，返回true    
// 不等进入上面循环，找到相等时会跳出循环，走到这里返回true    
return true
}
```


### 实现一个批量请求函数, 能够限制并发量?
```
function requestData(urls = [], max = 1, callback = () => {}) {
	const fetchArr = [];
	const requestArr = [];
	for(const item of urls) {
  	const p = fetch(item)
  	fetchArr.push(p)
  	// 如果最大限制比数组小我们才需要走这一步
  	if (max <= urls.length){
      const e = p.then(() => {
        requestArr.splice(requestArr.indexOf(p), 1)
      })
      requestArr.push(e)
      if(requestArr.length >= max){
        await Promise.race(requestArr)
      }
    }
  }
  Promise.all(fetchArr).then(() => {
    callback();  
  })
}
<!-- 	for (let i = 0, length = urls.length; i < length; i++) {
    requestArr.push(fetch(urls[i]))
  }
  Promies.all(requestArr).then(() => {
    callback()
  }).catch(err => {
    console.log(err)
  }) -->
```

### 数组与树结构相互转换
```
let data = [
  { id: 0, parentId: null, name: '生物' },
  { id: 1, parentId: 0, name: '动物' },
  { id: 2, parentId: 0, name: '植物' },
  { id: 3, parentId: 0, name: '微生物' },
  { id: 4, parentId: 1, name: '哺乳动物' },
  { id: 5, parentId: 1, name: '卵生动物' },
  { id: 6, parentId: 2, name: '种子植物' },
  { id: 7, parentId: 2, name: '蕨类植物' },
  { id: 8, parentId: 4, name: '大象' },
  { id: 9, parentId: 4, name: '海豚' },
  { id: 10, parentId: 4, name: '猩猩' },
  { id: 11, parentId: 5, name: '蟒蛇' },
  { id: 12, parentId: 5, name: '麻雀' }
]

let node = {
    "id": 0,
    "parentId": null,
    "name": "生物",
    "children": [{
        "id": 1,
        "parentId": 0,
        "name": "动物",
        "children": [{
            "id": 4,
            "parentId": 1,
            "name": "哺乳动物",
            "children": [{
                "id": 8,
                "parentId": 4,
                "name": "大象"
            }, {
                "id": 9,
                "parentId": 4,
                "name": "海豚"
            }, {
                "id": 10,
                "parentId": 4,
                "name": "猩猩"
            }]
        }, {
            "id": 5,
            "parentId": 1,
            "name": "卵生动物",
            "children": [{
                "id": 11,
                "parentId": 5,
                "name": "蟒蛇"
            }, {
                "id": 12,
                "parentId": 5,
                "name": "麻雀"
            }]
        }]
    }, {
        "id": 2,
        "parentId": 0,
        "name": "植物",
        "children": [{
            "id": 6,
            "parentId": 2,
            "name": "种子植物"
        }, {
            "id": 7,
            "parentId": 2,
            "name": "蕨类植物"
        }]
    }, {
        "id": 3,
        "parentId": 0,
        "name": "微生物"
    }]
}
```

```
const transTree = (data) => {
	let result = []
	let map = {}
	if(!Array.isArray(data)) { // 验证data是不是数组类型
  	return []
  }
	data.forEach(item => {
  	map[item.id] = item //浅拷贝，共享引用
  })
	data.forEach(item => {
  	let parent = map[item.parentId]
  	if(parent) {
    	(parent.children || (parent.children = [])).push(item)
    } else {
    	result.push(item)
    }
  })
	return result
}
```

```
const transArr = (node) => {
	let queue = [node];
	let data = []
	while (queue.length !== 0){
  	let item = queue.shift()
  	data.push({
    	id: item.id,
    	parentId: item.parentId,
    	name: item.name
    })
  	let children = item.children
  	if (children) {
    	for (let i =0; i < children.length; i ++) {
        queue.push(children[i])
      }
    }
  }
  return data
}
```

### 去除字符串中出现次数最少的字符，不改变原字符串的顺序。


### 写出一个函数trans，将数字转换成汉语的输出，输入为不超过10000亿的数字。


### 给几个数组, 可以通过数值找到对应的数组名称
```
给几个数组, 可以通过数值找到对应的数组名称
// 比如这个函数输入一个1，那么要求函数返回A
const A = [1,2,3];
const B = [4,5,6];
const C = [7,8,9];

function test(num) {

}
```

### 输出什么? 为什么?
```
var b = 10;
(function b(){
    b = 20;
    console.log(b);
})();
```

代码输出题
```
async function async1() {
  console.log('1');
  await async2();
  console.log('2');
}
 
async function async2() {
  console.log('3');
}
 
console.log('4');
 
setTimeout(function() {
    console.log('5');
}, 0);  
 
async1();
 
new Promise(function(resolve) {
    console.log('6');
    resolve();
  }).then(function() {
    console.log('7');
});
 
console.log('8');
```

### 
promise 链式
例如 promises = []，实现必须上一个异步完成后再去跑下一个任务。我是写出两种方案：
// 1.
const template = Promise.resolve();
promises.forEach((p) => {
template = template.then(p)
})
// 2. 使用 await
复制代码个人感觉对 promise、async/await 都问比较多，包括比较火的问打印顺序那种题还有捕获异常的问题我也遇到过，只要对语法非常熟悉加上稍微了解实现细节都是没问题。


### 事件委托

### Event Loop
JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：
（1）所有同步任务都在主线程上执行，形成一个执行栈。
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
event loop 基本每次都会被问到，一般就是说微任务、宏任务，怎么样的运行过程，以上是比较书面一点的回答，我自己也没记得。

### new queue().task(fn,1000).task(fn,2000).task(fn,3000).run() 根据1000,2000,3000延时输出 补全queue

### [1,0,2,0,3,12]=>[1,2,3,12,0,0]把0往后排,然后非0数字顺序不变,不使用额外空间


### 使用Promise实现一个异步流量控制的函数, 比如一共10个请求, 每个请求的快慢不同, 最多同时3个请求发出, 快的一个请求返回后, 就从剩下的7个请求里再找一个放进请求池里, 如此循环。


### 给一个字符串, 找到第一个不重复的字符
ababcbdsa abcdefg


```
// 题目需求

let middleware = []
middleware.push((next) => {
    console.log(1)
    next()
    console.log(1.1)
})
middleware.push((next) => {
    console.log(2)
    next()
    console.log(2.1)
})
middleware.push((next) => {
    console.log(3)
    next()
    console.log(3.1)
})

let fn = compose(middleware)
fn()


/*
1
2
3
3.1
2.1
1.1
*/

//实现compose函数
function compose(middlewares) {
    
}

```