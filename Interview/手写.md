### 手写 promise

重点是需要实现 Promise.then 方法
维护一个 fullfilled 的事件队列和一个 rejected 事件队列
在 Promise.then 方法里需要判断一下当前 Promise 的状态以及参数类型
最后需要实现两个事件队列的自执行，用来处理链式调用的情况
在执行方法时使用 setTimeout 模拟异步任务

### 实现一个节流函数? 如果想要最后一次必须执行的话怎么实现?

### 手写 promise

### 手写 bind

### 手写 eventEmitter

跟 promise class 一样，先搭建一个框架：
class EventEmitter {
constructor() {
this.events = {}
}
emit (eventName, args) {}
on (eventName, callback) {}
off (eventName, callback?) {}
}
复制代码之前有写过事件系统，但是没有考虑 once 之类的 method，也是面试官说了需求再一点点补充的。

### 手写 Proxy / Object.defineProperty

实际只是要求两者的比较以及如何运用

### 手写深拷贝

### 、实现 instanceOf 的 3 种方法

```
function myInstanceof(obj, func) {
	if(!['function', 'object'].includes(typeof obj) || obj === null) {
		// 基本数据类型直接返回false，因为不满足instanceof的左侧参数是对象或者说引用类型
			return false
	}
	let proto = obj.__proto__, prototype = func.prototype
	while(proto !== prototype) {
		// obj.__proto__不等于func.prototype时，继续通过__proto__向上层查找
		// 当找到原型链尽头Object.prototype.__proto__=null 时还未找到，就返回false
		proto = proto.__proto__
		if(proto === null){
			return false
		}
	}
// obj.__proto__ 等于 prototype = func.prototype 时，不会进入上面循环，返回true
// 不等进入上面循环，找到相等时会跳出循环，走到这里返回true
return true
}
```

### 数组与树结构相互转换

```
let data = [
  { id: 0, parentId: null, name: '生物' },
  { id: 1, parentId: 0, name: '动物' },
  { id: 2, parentId: 0, name: '植物' },
  { id: 3, parentId: 0, name: '微生物' },
  { id: 4, parentId: 1, name: '哺乳动物' },
  { id: 5, parentId: 1, name: '卵生动物' },
  { id: 6, parentId: 2, name: '种子植物' },
  { id: 7, parentId: 2, name: '蕨类植物' },
  { id: 8, parentId: 4, name: '大象' },
  { id: 9, parentId: 4, name: '海豚' },
  { id: 10, parentId: 4, name: '猩猩' },
  { id: 11, parentId: 5, name: '蟒蛇' },
  { id: 12, parentId: 5, name: '麻雀' }
]

let node = {
    "id": 0,
    "parentId": null,
    "name": "生物",
    "children": [{
        "id": 1,
        "parentId": 0,
        "name": "动物",
        "children": [{
            "id": 4,
            "parentId": 1,
            "name": "哺乳动物",
            "children": [{
                "id": 8,
                "parentId": 4,
                "name": "大象"
            }, {
                "id": 9,
                "parentId": 4,
                "name": "海豚"
            }, {
                "id": 10,
                "parentId": 4,
                "name": "猩猩"
            }]
        }, {
            "id": 5,
            "parentId": 1,
            "name": "卵生动物",
            "children": [{
                "id": 11,
                "parentId": 5,
                "name": "蟒蛇"
            }, {
                "id": 12,
                "parentId": 5,
                "name": "麻雀"
            }]
        }]
    }, {
        "id": 2,
        "parentId": 0,
        "name": "植物",
        "children": [{
            "id": 6,
            "parentId": 2,
            "name": "种子植物"
        }, {
            "id": 7,
            "parentId": 2,
            "name": "蕨类植物"
        }]
    }, {
        "id": 3,
        "parentId": 0,
        "name": "微生物"
    }]
}
```

```
const transTree = (data) => {
	let result = []
	let map = {}
	if(!Array.isArray(data)) { // 验证data是不是数组类型
  	return []
  }
	data.forEach(item => {
  	map[item.id] = item //浅拷贝，共享引用
  })
	data.forEach(item => {
  	let parent = map[item.parentId]
  	if(parent) {
    	(parent.children || (parent.children = [])).push(item)
    } else {
    	result.push(item)
    }
  })
	return result
}
```

```
const transArr = (node) => {
	let queue = [node];
	let data = []
	while (queue.length !== 0){
  	let item = queue.shift()
  	data.push({
    	id: item.id,
    	parentId: item.parentId,
    	name: item.name
    })
  	let children = item.children
  	if (children) {
    	for (let i =0; i < children.length; i ++) {
        queue.push(children[i])
      }
    }
  }
  return data
}
```

### 去除字符串中出现次数最少的字符，不改变原字符串的顺序。

### 写出一个函数 trans，将数字转换成汉语的输出，输入为不超过 10000 亿的数字。

### 给几个数组, 可以通过数值找到对应的数组名称

```
给几个数组, 可以通过数值找到对应的数组名称
// 比如这个函数输入一个1，那么要求函数返回A
const A = [1,2,3];
const B = [4,5,6];
const C = [7,8,9];

function test(num) {

}
```

### 输出什么? 为什么?

```
var b = 10;
(function b(){
    b = 20;
    console.log(b);
})();
```

代码输出题

```
async function async1() {
  console.log('1');
  await async2();
  console.log('2');
}

async function async2() {
  console.log('3');
}

console.log('4');

setTimeout(function() {
    console.log('5');
}, 0);

async1();

new Promise(function(resolve) {
    console.log('6');
    resolve();
  }).then(function() {
    console.log('7');
});

console.log('8');
```

###

promise 链式
例如 promises = []，实现必须上一个异步完成后再去跑下一个任务。我是写出两种方案：
// 1.
const template = Promise.resolve();
promises.forEach((p) => {
template = template.then(p)
})
// 2. 使用 await
复制代码个人感觉对 promise、async/await 都问比较多，包括比较火的问打印顺序那种题还有捕获异常的问题我也遇到过，只要对语法非常熟悉加上稍微了解实现细节都是没问题。

### 事件委托

### Event Loop

JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤：
（1）所有同步任务都在主线程上执行，形成一个执行栈。
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
（4）主线程不断重复上面的第三步。
event loop 基本每次都会被问到，一般就是说微任务、宏任务，怎么样的运行过程，以上是比较书面一点的回答，我自己也没记得。

### new queue().task(fn,1000).task(fn,2000).task(fn,3000).run() 根据 1000,2000,3000 延时输出 补全 queue

### [1,0,2,0,3,12]=>[1,2,3,12,0,0]把 0 往后排,然后非 0 数字顺序不变,不使用额外空间

### 使用 Promise 实现一个异步流量控制的函数, 比如一共 10 个请求, 每个请求的快慢不同, 最多同时 3 个请求发出, 快的一个请求返回后, 就从剩下的 7 个请求里再找一个放进请求池里, 如此循环。

### 给一个字符串, 找到第一个不重复的字符

ababcbdsa abcdefg

```
// 题目需求

let middleware = []
middleware.push((next) => {
    console.log(1)
    next()
    console.log(1.1)
})
middleware.push((next) => {
    console.log(2)
    next()
    console.log(2.1)
})
middleware.push((next) => {
    console.log(3)
    next()
    console.log(3.1)
})

let fn = compose(middleware)
fn()


/*
1
2
3
3.1
2.1
1.1
*/

//实现compose函数
function compose(middlewares) {

}

```

【代码题】大数相加

输入：num1 = '1234567890', num2 = '987654321'
输出：'2222222211'

```
//  这是一道比较简单的题目，主要就是模拟加法进位的实现
const add = (num1, num2) => {
    const n = Math.max(num1.length, num2.length);
    //  逆序一下，从最后一位开始相加，同时前面位数不够的补0
    const arr1 = num1.split('').reverse();
    const arr2 = num2.split('').reverse();
    const result = [];
    //  进位的标识，只有进1位和不进位两种情况
    let temp = 0;
    for (let i = 0; i < n; i++) {
        const a = +(arr1[i] || 0);
        const b = +(arr2[i] || 0);
        let current = a + b + temp;
        if (current >= 10) {
            temp = 1;
            current -= 10;
        } else {
            temp = 0;
        }
        result.push(current);
    }
    //  考虑到进位导致的量级增加情况，需要额外处理
    if (temp) {
        result.push(temp);
    }
    return result.reverse().join('');
}

```

【代码题】实现一个同步的 sleep 方法
调用方式：(new LazyLog()).log(1).sleep(1000).log(2)
输出：先输出 1，延迟 1 秒后输出 2

```
//  一开始我的想法是通过Promise去实现sleep，后来发现Promise的话无法满足直接的链式调用方式
//  面完之后下来查了一下，发现可以通过死循环去实现同步的sleep，但是这种方式对性能有极大的影响
//  在某些环境下会执行报错，后来又去查了一下开源的sleep库https://www.npmjs.com/package/sleep
//  发现它的最终也是通过c++原生代码编译成node模块来实现的，所以这个问题有没有啥更好的答案呢🤔
class LazyLog {
  log(str) {
    console.log(str)
    return this;
  }

  // async sleep(delay) {
  //   await new Promise(resolve => setTimeout(() => resolve(), delay));
  //   return this;
  // }

  sleep(delay) {
    const current = Date.now();
    while (Date.now() - current < delay) {
      // 什么都不做
    }
    return this;
  }
}

```

按照 Z 字型打印矩阵
输入：[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
输出：1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16

```
//  这个题我是没有想到更好的思路，感觉就是纯暴力破解
//  从左上角的点开始，先往右上角走，走到边界的时候就开始往左下角走，到边界再换方向
//  核心的点就是对于边界的判断要准确，这个我在面试的时候没写出来，复盘也试了好久才正确🤦🏻‍
const print = arr => {
  let i = 0;
  let j = 0;
  let rows = arr.length;
  let cols = arr[0].length;
  let gotoRightTop = true;
  const result = [];
  //  最后一定是超出行或者列了
  while (arr[i] && arr[i][j]) {
    result.push(arr[i][j]);

    //  往右上角走的时候，列要加1，行要减1
    if (gotoRightTop) {
      j++;
      //  如果列出界了，说明该往下移动一个并且更换方向
      if (j > cols - 1) {
        gotoRightTop = false;
        i++;
        j = cols - 1;
        continue;
      }

      i--;
      //  如果行出界了，那么需要回到界内且更换方向
      if (i < 0) {
        gotoRightTop = false;
        i = 0;
      }

    //  这是往左下走的情况，逻辑是一样的
    } else {
      i++;

      if (i > rows - 1) {
        gotoRightTop = true;
        j++;
        i = rows - 1;
        continue;
      }

      j--;
      if (j < 0) {
        gotoRightTop = true;
        j = 0;
      }
    }
  }
  return result;
}

```

实现一个实时搜索框组件
const SearchBox = ({ onChange }) => {
const lockRef = useRef(0);
const [searchList, setSearchList] = useState([]);

    const onInput = async e => {
        lockRef.current += 1;
        const temp = lockRef.current;
        try {
            const res = await fetch("/api/search", e.target.value);
            //  处理竞态条件
            if (lockRef.current !== temp) return;
            setSearchList(res.json());
        } catch (error) {
            console.log(error);
        }
    };

    return (
        <div className="search-wrapper">
            <input type="text" onInput={onInput} />
            <ul className="complete-list">
                {searchList.map(item => (
                    <li key={item.value} onClick={onChange(item)}>
                        {item.label}
                    </li>
                ))}
            </ul>
        </div>
    );

};

查找有序数组中数字最后一次出现的位置
输入：nums = [5,7,7,8,8,10], target = 8
输出：4

// 最简答的方式就是直接遍历然后根据有序的条件找到当前值等于目标且下一个值不等于目标的结果
// 写出来之后面试官问了时间复杂度，这个就是单层循环的 O(N)，最坏情况就是刚好最后一个值是目标值
const findLast = (nums, target) => {
for (let i = 0; i < nums.length; i++) {
if (target === nums[i] && target !== nums[i + 1]) {
return i;
}
}
return -1;
};

// 问有没有更好的方式，就想到了二分查找，对于已经有序的数组，只需要通过双指针不断更新左右边界位置就行
// 二分法最主要的就是寻找二分结束的边界条件，这里选择所有的查找最后都只剩两个值
// 然后对这两个值再额外判断一下是否符合结果
// 面试官继续追问二分法的时间复杂度，这个我有点懵，不过考虑跟递归差不多，所以就回答了 O(logN)，应该是没错
// 二分查找最坏的情况是刚好第一个值或者最后一个值，或者中间值是目标值
const findLast2 = (nums, target) => {
let left = 0;
let right = nums.length - 1;
while (right > left + 1) {
const mid = Math.floor((left + right) / 2);
if (nums[mid] > target) {
right = mid - 1;
} else {
left = mid;
}
}
if (nums[right] === target) {
return right;
}
if (nums[left] === target) {
return left;
}
return -1;
};
